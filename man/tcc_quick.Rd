% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tcc_quick.R
\name{tcc_quick}
\alias{tcc_quick}
\title{Compile a small declare()-annotated R subset with TinyCC}
\usage{
tcc_quick(
  fn,
  fallback = c("auto", "always", "never"),
  mode = c("compile", "code"),
  debug = FALSE
)
}
\arguments{
\item{fn}{Function to compile.}

\item{fallback}{One of \code{"auto"}, \code{"always"}, or \code{"never"}.}

\item{mode}{One of \code{"compile"} (default) or \code{"code"}. Use \code{"code"}
to return generated C source without compiling.}

\item{debug}{Print generated C source and lowering diagnostics.}
}
\value{
A function with the same formals as \code{fn}, or \code{fn} itself when
fallback is used. When \code{mode = "code"}, returns a character string
containing generated C source.
}
\description{
\code{tcc_quick()} is an experimental C-first path for compiling a strict subset
of R functions annotated with \code{declare(type(...))}. In the current subset, supported
bodies are recursive scalar expressions (arithmetic, comparisons, logical
operators, unary operators, selected scalar math functions, and scalar
\code{if (cond) a else b}/\code{ifelse(cond, a, b)}) over declared scalar
\code{double}/\code{integer}/\code{logical} arguments. Simple statement blocks with
scalar \verb{<-} assignments before the final expression are supported.
}
\details{
For non-arithmetic two-argument calls (e.g. \code{max(x, y)}), \code{tcc_quick()}
emits a wrapper that constructs the call via \code{Rf_lang3()} and evaluates it
in base, so R's primitive/internal implementation is used.

Lowering descends recursively through expressions and stops at boundary calls
(\code{.Call}, \code{.C}, \code{.External}, \code{.Internal}, \code{.Primitive}), where it currently
falls back according to \code{fallback}.

Unsupported functions can either fallback to the original R function or
error, depending on \code{fallback}.
}
