---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# Rtinycc

<!-- badges: start -->
[![R-CMD-check](https://github.com/sounkou-bioinfo/Rtinycc/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/sounkou-bioinfo/Rtinycc/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

We provide a simple R interface to the [tinycc](https://github.com/TinyCC/tinycc) compiler including the cli and the libtcc library. This is mainly a vehicule for the tinycc compiler and libtcc library. A simple FFI interface inspired by [bun's FFI](https://bun.com/docs/runtime/ffi) is included. We do not support windows.

## Installation

``` r
remotes::install_github("sounkou-bioinfo/Rtinycc")
```

## Example

### CLI

```{r cli}
library(Rtinycc)
tcc_dir <- tcc_prefix()
# CLI compile to executable
src <- system.file("c_examples", "forty_two.c", package = "Rtinycc")
exe <- tempfile(fileext = if (.Platform$OS.type == "windows") ".exe" else "")
inc_args <- paste0("-I", tcc_include_paths())
lib_args <- paste0("-L", tcc_lib_paths())
status <- tcc_run_cli(c("-B", tcc_dir, inc_args, lib_args, src, "-o", exe))
status
Sys.chmod(exe, mode = "0755")
system2(exe, stdout = TRUE)
```
### In memory using libtcc

```{r in-memory}
# libtcc in-memory compile
state <- tcc_state(output = "memory")
code <- "int forty_two(){ return 42; }"
tcc_compile_string(state, code)
tcc_relocate(state)
tcc_call_symbol(state, "forty_two", return = "int")
tcc_get_symbol(state, "forty_two")
```

### Low Level API For Calling C code

Using `#Define _Complex` as workaround of  `TinyCC`'s lack of support for complex types, we can link against R's install headers and `libR` to call R's C API function.

```{r call-R-C-API}
# Create new state for R linking example
state <- tcc_state(output = "memory")

# Add R include and library paths using Rtinycc functions
r_include <- R.home("include")
r_lib <- file.path(R.home("lib"))

tcc_add_include_path(state, r_include)
tcc_add_library_path(state, r_lib)

# Link against external math library (libm) for real math functions
tcc_add_library(state, "m")

# C code that demonstrates actual R C API usage
# Workaround: Define _Complex to empty since TinyCC doesn't support complex types
code <- '
#define _Complex
#include <R.h>
#include <Rinternals.h>

void hello_world() {
  Rprintf("Hello World from compiled C code!\\n");
}

// Create an R numeric vector and calculate its length
int create_r_vector() {
  SEXP vec = PROTECT(Rf_allocVector(REALSXP, 5));
  for(int i = 0; i < 5; i++) {
    REAL(vec)[i] = (double)(i + 1) * 2.0;  // 2, 4, 6, 8, 10
  }
  
  int length = Rf_length(vec);
  Rprintf("Created vector length: %d\\n", length);
  Rprintf("Vector values: ");
  for(int i = 0; i < length; i++) {
    Rprintf("%f ", REAL(vec)[i]);
  }
  Rprintf("\\n");
  
  UNPROTECT(1);
  return length;
}

// Use Rf_install to get a function and call it
double call_r_function() {
  // Get the sqrt function from R base
  SEXP sqrt_fun = PROTECT(Rf_findFun(Rf_install("sqrt"), R_BaseEnv));
  
  // Create a scalar value
  SEXP val = PROTECT(Rf_ScalarReal(16.0));
  
  // Call the function
  SEXP result = PROTECT(Rf_lang2(sqrt_fun, val));
  SEXP eval_result = PROTECT(Rf_eval(result, R_GlobalEnv));
  
  double sqrt_val = REAL(eval_result)[0];
  Rprintf("R sqrt(16.0) = %f\\n", sqrt_val);
  
  UNPROTECT(4);
  return sqrt_val;
}

// Demonstrate creating different R data types
void demonstrate_r_types() {
  // Create different types of R objects
  SEXP int_vec = PROTECT(Rf_allocVector(INTSXP, 3));
  INTEGER(int_vec)[0] = 1;
  INTEGER(int_vec)[1] = 2;
  INTEGER(int_vec)[2] = 3;
  Rprintf("Integer vector created with %d elements\\n", Rf_length(int_vec));
  
  SEXP str_vec = PROTECT(Rf_allocVector(STRSXP, 2));
  SET_STRING_ELT(str_vec, 0, Rf_mkChar("Hello"));
  SET_STRING_ELT(str_vec, 1, Rf_mkChar("R"));
  Rprintf("String vector created with %d elements\\n", Rf_length(str_vec));
  
  SEXP logical = PROTECT(Rf_ScalarLogical(TRUE));
  Rprintf("Logical value: %d\\n", LOGICAL(logical)[0]);
  
  UNPROTECT(3);
}
'

tcc_compile_string(state, code)
tcc_relocate(state)


# Call the functions that demonstrate R C API usage
tcc_call_symbol(state, "hello_world", return = "void")

result1 <- tcc_call_symbol(state, "create_r_vector", return = "int")
result1

result2 <- tcc_call_symbol(state, "call_r_function", return = "double") 
result2

result3 <- tcc_call_symbol(state, "demonstrate_r_types", return = "void")
```

### A declarative FFI API 

A declarative interface inspired by [Bun:FFI](https://bun.com/docs/runtime/ffi) is provided. Define types explicitly and let `Rtinycc` generate the binding code automatically by using `TinyCC` to compile a dll.

#### Type System

The FFI type system maps R types to C types:

- **Scalars**: `i8`, `i16`, `i32`, `i64` (integers), `f32`, `f64` (floats), `bool`, `cstring`
- **Arrays** (zero-copy): `raw` → `uint8_t*`, `integer_array` → `int32_t*`, `numeric_array` → `double*`
- **Pointers**: `ptr` (externalptr), `sexp` (R object)

#### Example: Simple Function

```{r ffi-simple}

# Define and compile in one chain
ffi <- tcc_ffi() |>
  tcc_bind(
    add = list(args = list("i32", "i32"), returns = "i32")
  ) |>
  tcc_source("
    int add(int a, int b) {
      return a + b;
    }
  ") |>
  tcc_compile()

# Call directly with type conversion
result <- ffi$add(5L, 3L)
result
```

#### Example: Working with R Arrays

Pass R vectors to C with zero-copy:

```{r ffi-arrays}
ffi <- tcc_ffi() |>
  tcc_bind(
    sum_array = list(args = list("integer_array", "i32"), returns = "i64")
  ) |>
  tcc_source("
    int64_t sum_array(int32_t* arr, int32_t n) {
      int64_t sum = 0;
      for(int i = 0; i < n; i++) {
        sum += arr[i];
      }
      return sum;
    }
  ") |>
  tcc_compile()

# Pass R integer vector directly
x <- 1:100
result <- ffi$sum_array(x, length(x))
result
```

#### Linking External Libraries

Link against system libraries like libm 

```{r ffi-link, eval=TRUE}
# Link against math library
math_lib <- tcc_link(
  "libm.so.6",
  symbols = list(
    sqrt = list(args = list("f64"), returns = "f64"),
    sin = list(args = list("f64"), returns = "f64")
  )
)

math_lib$sqrt(16.0)
```

#### Linking SQLite3

you can link again the libraries and access the exported symbol

```{r ffi-link-sqlite, eval=TRUE}
# Link the system SQLite3 library and expose a few symbols
sqlite <- tcc_link(
  "libsqlite3.so",
  symbols = list(
    sqlite3_libversion = list(args = list(), returns = "cstring"),
    sqlite3_open = list(args = list("cstring", "ptr"), returns = "i32"),
    sqlite3_close = list(args = list("ptr"), returns = "i32"),
    sqlite3_exec = list(args = list("ptr", "cstring", "ptr", "ptr", "ptr"), returns = "i32")
  ),
  libs = "sqlite3"
)

# Query the SQLite library version
sqlite$sqlite3_libversion()
```

#### In-Memory Database with Helper Functions

Create user-friendly helper functions for SQLite operations:

```{r ffi-sqlite-inmemory, eval=TRUE}
# Create SQLite with helper functions
sqlite_with_helpers <- tcc_ffi()
sqlite_with_helpers <- tcc_header(sqlite_with_helpers, '#include <sqlite3.h>')
sqlite_with_helpers <- tcc_library(sqlite_with_helpers, "sqlite3")
sqlite_with_helpers <- tcc_source(sqlite_with_helpers, '
  #include <sqlite3.h>
  
  void* tcc_create_inmemory_db() {
    sqlite3* db = NULL;
    sqlite3_open(":memory:", &db);
    return db;
  }
  
  int tcc_exec_sql(void* db_ptr, const char* sql) {
    sqlite3* db = (sqlite3*)db_ptr;
    char* err_msg = NULL;
    int rc = sqlite3_exec(db, sql, NULL, NULL, &err_msg);
    if (err_msg) sqlite3_free(err_msg);
    return rc;
  }
')
sqlite_with_helpers <- tcc_bind(sqlite_with_helpers,
  sqlite3_libversion = list(args = list(), returns = "cstring"),
  sqlite3_close = list(args = list("ptr"), returns = "i32"),
  tcc_create_inmemory_db = list(args = list(), returns = "ptr"),
  tcc_exec_sql = list(args = list("ptr", "cstring"), returns = "i32")
)
sqlite_with_helpers <- tcc_compile(sqlite_with_helpers)

# Create in-memory database and use it
db <- sqlite_with_helpers$tcc_create_inmemory_db()
sqlite_with_helpers$tcc_exec_sql(db, "CREATE TABLE users (id INTEGER, name TEXT);")
sqlite_with_helpers$tcc_exec_sql(db, "INSERT INTO users VALUES (1, 'Alice');")
sqlite_with_helpers$tcc_exec_sql(db, "INSERT INTO users VALUES (2, 'Bob');")

sqlite_with_helpers$sqlite3_libversion()
sqlite_with_helpers$sqlite3_close(db)
```

#### SQLite with Pointer Utilities

Using generic pointer utilities for cleaner SQLite operations:

```{r ffi-sqlite-pointers, eval=TRUE}
# Create SQLite with pointer utilities integration
sqlite_with_utils <- tcc_ffi() |>
  tcc_header('#include <sqlite3.h>') |>
  tcc_library("sqlite3") |>
  tcc_source('
    #include <sqlite3.h>
  
  // Helper to create in-memory database
  void* tcc_create_inmemory_db_with_utils() {
    sqlite3* db = NULL;
    sqlite3_open(":memory:", &db);
    return db;
  }
  
  // Helper that executes SQL
  int tcc_exec_with_utils(void* db_ptr, const char* sql) {
    sqlite3* db = (sqlite3*)db_ptr;
    char* err_msg = NULL;
    int rc = sqlite3_exec(db, sql, NULL, NULL, &err_msg);
    if (err_msg) {
      sqlite3_free(err_msg);
    }
    return rc;
  }
  
  // Helper to create and populate database
  void* tcc_setup_test_db() {
    sqlite3* db = NULL;
    sqlite3_open(":memory:", &db);
    if (db) {
      sqlite3_exec(db, "CREATE TABLE items (id INTEGER, name TEXT);", NULL, NULL, NULL);
      sqlite3_exec(db, "INSERT INTO items VALUES (1, test);", NULL, NULL, NULL);
    }
    return db;
  }
') |>
  tcc_bind(
    sqlite3_libversion = list(args = list(), returns = "cstring"),
    sqlite3_close = list(args = list("ptr"), returns = "i32"),
    tcc_create_inmemory_db_with_utils = list(args = list(), returns = "ptr"),
    tcc_exec_with_utils = list(args = list("ptr", "cstring"), returns = "i32"),
    tcc_setup_test_db = list(args = list(), returns = "ptr")
  ) |>
  tcc_compile()

# Use pointer utilities with SQLite
db <- sqlite_with_utils$tcc_setup_test_db()
tcc_ptr_addr(db, hex = TRUE)

result <- sqlite_with_utils$tcc_exec_with_utils(db, "SELECT COUNT(*) FROM items;")
sqlite_with_utils$sqlite3_libversion()
sqlite_with_utils$sqlite3_close(db)
```

#### Custom Wrappers

You can also create custom wrapper functions:

```{r ffi-source-with-link, eval=TRUE}
compiled <- tcc_ffi()
compiled <- tcc_output(compiled, "memory")
compiled <- tcc_header(compiled, '#include <sqlite3.h>')
compiled <- tcc_library(compiled, "sqlite3")
compiled <- tcc_source(compiled,
  paste0(
    "const char* get_sqlite_version() {\n",
    "  return sqlite3_libversion();\n",
    "}\n"
  )
)
compiled <- tcc_bind(compiled,
  get_sqlite_version = list(args = list(), returns = "cstring")
)
compiled <- tcc_compile(compiled)

compiled$get_sqlite_version()
```

## License

GPL-3

# References

- [tinycc](https://github.com/TinyCC/tinycc)
- [bun's FFI](https://bun.com/docs/runtime/ffi)
