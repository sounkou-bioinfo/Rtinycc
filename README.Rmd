---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# Rtinycc

<!-- badges: start -->
[![R-CMD-check](https://github.com/sounkou-bioinfo/Rtinycc/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/sounkou-bioinfo/Rtinycc/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

We provide a simple R interface to the [tinycc](https://github.com/TinyCC/tinycc) compiler including the cli and the libtcc library. This is mainly a vehicule for the tinycc compiler and libtcc library. A simple FFI interface inspired by [bun's FFI](https://bun.com/docs/runtime/ffi) is included .We do not support windows.

## Installation

``` r
remotes::install_github("sounkou-bioinfo/Rtinycc")
```

## Example

### CLI

```{r cli}
library(Rtinycc)
tcc_dir <- tcc_prefix()
# CLI compile to executable
src <- system.file("c_examples", "forty_two.c", package = "Rtinycc")
exe <- tempfile(fileext = if (.Platform$OS.type == "windows") ".exe" else "")
inc_args <- paste0("-I", tcc_include_paths())
lib_args <- paste0("-L", tcc_lib_paths())
status <- tcc_run_cli(c("-B", tcc_dir, inc_args, lib_args, src, "-o", exe))
status
Sys.chmod(exe, mode = "0755")
system2(exe, stdout = TRUE)
```
### In memory using libtcc

```{r in-memory}
# libtcc in-memory compile
state <- tcc_state(output = "memory")
code <- "int forty_two(){ return 42; }"
tcc_compile_string(state, code)
tcc_relocate(state)
tcc_call_symbol(state, "forty_two", return = "int")
tcc_get_symbol(state, "forty_two")
```

### Low Level API For Calling C code

Using `#Define _Complex` as workaround of  `TinyCC`'s lack of support for complex types, we can link against R's install headers and `libR` to call R's C API function.

```{r call-R-C-API}
# Create new state for R linking example
state <- tcc_state(output = "memory")

# Add R include and library paths using Rtinycc functions
r_include <- R.home("include")
r_lib <- file.path(R.home("lib"))

tcc_add_include_path(state, r_include)
tcc_add_library_path(state, r_lib)

# Link against external math library (libm) for real math functions
tcc_add_library(state, "m")

# C code that demonstrates actual R C API usage
# Workaround: Define _Complex to empty since TinyCC doesn't support complex types
code <- '
#define _Complex
#include <R.h>
#include <Rinternals.h>

void hello_world() {
  Rprintf("Hello World from compiled C code!\\n");
}

// Create an R numeric vector and calculate its length
int create_r_vector() {
  SEXP vec = PROTECT(Rf_allocVector(REALSXP, 5));
  for(int i = 0; i < 5; i++) {
    REAL(vec)[i] = (double)(i + 1) * 2.0;  // 2, 4, 6, 8, 10
  }
  
  int length = Rf_length(vec);
  Rprintf("Created vector length: %d\\n", length);
  Rprintf("Vector values: ");
  for(int i = 0; i < length; i++) {
    Rprintf("%f ", REAL(vec)[i]);
  }
  Rprintf("\\n");
  
  UNPROTECT(1);
  return length;
}

// Use Rf_install to get a function and call it
double call_r_function() {
  // Get the sqrt function from R base
  SEXP sqrt_fun = PROTECT(Rf_findFun(Rf_install("sqrt"), R_BaseEnv));
  
  // Create a scalar value
  SEXP val = PROTECT(Rf_ScalarReal(16.0));
  
  // Call the function
  SEXP result = PROTECT(Rf_lang2(sqrt_fun, val));
  SEXP eval_result = PROTECT(Rf_eval(result, R_GlobalEnv));
  
  double sqrt_val = REAL(eval_result)[0];
  Rprintf("R sqrt(16.0) = %f\\n", sqrt_val);
  
  UNPROTECT(4);
  return sqrt_val;
}

// Demonstrate creating different R data types
void demonstrate_r_types() {
  // Create different types of R objects
  SEXP int_vec = PROTECT(Rf_allocVector(INTSXP, 3));
  INTEGER(int_vec)[0] = 1;
  INTEGER(int_vec)[1] = 2;
  INTEGER(int_vec)[2] = 3;
  Rprintf("Integer vector created with %d elements\\n", Rf_length(int_vec));
  
  SEXP str_vec = PROTECT(Rf_allocVector(STRSXP, 2));
  SET_STRING_ELT(str_vec, 0, Rf_mkChar("Hello"));
  SET_STRING_ELT(str_vec, 1, Rf_mkChar("R"));
  Rprintf("String vector created with %d elements\\n", Rf_length(str_vec));
  
  SEXP logical = PROTECT(Rf_ScalarLogical(TRUE));
  Rprintf("Logical value: %d\\n", LOGICAL(logical)[0]);
  
  UNPROTECT(3);
}
'

tcc_compile_string(state, code)
tcc_relocate(state)


# Call the functions that demonstrate R C API usage
tcc_call_symbol(state, "hello_world", return = "void")

result1 <- tcc_call_symbol(state, "create_r_vector", return = "int")
result1

result2 <- tcc_call_symbol(state, "call_r_function", return = "double") 
result2

result3 <- tcc_call_symbol(state, "demonstrate_r_types", return = "void")
```

### Modern FFI API (Bun-style)

A declarative interface inspired by [Bun:FFI](https://bun.com/docs/runtime/ffi) is provided. Define types explicitly and let `Rtinycc` generate the binding code automatically by using `TinyCC` to compile a dll.

#### Type System

The FFI type system maps R types to C types:

- **Scalars**: `i8`, `i16`, `i32`, `i64` (integers), `f32`, `f64` (floats), `bool`, `cstring`
- **Arrays** (zero-copy): `raw` → `uint8_t*`, `integer_array` → `int32_t*`, `numeric_array` → `double*`
- **Pointers**: `ptr` (externalptr), `sexp` (R object)

#### Example: Simple Function

```{r ffi-simple}

# Define and compile in one chain
ffi <- tcc_ffi() |>
  tcc_bind(
    add = list(args = list("i32", "i32"), returns = "i32")
  ) |>
  tcc_source("
    int add(int a, int b) {
      return a + b;
    }
  ") |>
  tcc_compile()

# Call directly with type conversion
result <- ffi$add(5L, 3L)
result
```

#### Example: Working with R Arrays

Pass R vectors to C with zero-copy:

```{r ffi-arrays}
ffi <- tcc_ffi() |>
  tcc_bind(
    sum_array = list(args = list("integer_array", "i32"), returns = "i64")
  ) |>
  tcc_source("
    int64_t sum_array(int32_t* arr, int32_t n) {
      int64_t sum = 0;
      for(int i = 0; i < n; i++) {
        sum += arr[i];
      }
      return sum;
    }
  ") |>
  tcc_compile()

# Pass R integer vector directly
x <- 1:100
result <- ffi$sum_array(x, length(x))
result
```

#### Linking External Libraries

Link against system libraries like libm 

```{r ffi-link, eval=TRUE}
# Link against math library
math_lib <- tcc_link(
  "libm.so.6",
  symbols = list(
    sqrt = list(args = list("f64"), returns = "f64"),
    sin = list(args = list("f64"), returns = "f64")
  )
)

# Use directly
math_lib$sqrt(16.0)
```

## License

GPL-3

# References

- [tinycc](https://github.com/TinyCC/tinycc)
- [bun's FFI](https://bun.com/docs/runtime/ffi)
