name: win_gdb

on:
  workflow_dispatch:
    inputs:
      runs:
        description: "How many repeated check attempts before giving up"
        required: false
        default: "3"

permissions: read-all

jobs:
  win-gdb:
    runs-on: windows-latest
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
      R_KEEP_PKG_SOURCE: yes
      R_REMOTES_NO_ERRORS_FROM_WARNINGS: true

    steps:
      - uses: actions/checkout@v4

      - uses: r-lib/actions/setup-r@v2
        with:
          r-version: release
          use-public-rspm: true

      - uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: any::rcmdcheck
          needs: check

      - name: Ensure gdb is available (MSYS2/Rtools)
        shell: bash
        run: |
          set -euxo pipefail
          if command -v gdb >/dev/null 2>&1; then
            gdb --version
            exit 0
          fi
          if command -v pacman >/dev/null 2>&1; then
            pacman -S --noconfirm --needed gdb
          fi
          command -v gdb
          gdb --version

      - name: Toolchain info
        shell: bash
        run: |
          set -euxo pipefail
          which R
          R --version
          which gdb || true
          gdb --version || true


      - name: Inspect Windows CRT linkage (Rtinycc/libtcc)
        shell: bash
        run: |
          set -euxo pipefail
          DEBUG_DIR="${RUNNER_TEMP:-$TMPDIR}/win_gdb"
          ARTDIR="$DEBUG_DIR/crt"
          mkdir -p "$ARTDIR"

          R CMD build . --no-build-vignettes > "$ARTDIR/build.log" 2>&1
          PKG=$(ls -1t *.tar.gz | head -n1)
          R CMD INSTALL "$PKG" > "$ARTDIR/install.log" 2>&1

          Rscript -e 'cat(normalizePath(system.file(package="Rtinycc"), winslash = "/", mustWork = TRUE))' > "$ARTDIR/pkg_root.txt"
          PKGROOT=$(tr -d '\r\n' < "$ARTDIR/pkg_root.txt")

          OBJDUMP=$(command -v x86_64-w64-mingw32-objdump || command -v objdump)
          echo "objdump=$OBJDUMP" > "$ARTDIR/objdump.txt"

          "$OBJDUMP" -p "$PKGROOT/libs/x64/Rtinycc.dll" > "$ARTDIR/Rtinycc.dll.imports.txt" || true
          "$OBJDUMP" -p "$PKGROOT/libs/x64/libtcc.dll" > "$ARTDIR/libtcc.dll.imports.txt" || true

          grep -Ein "DLL Name|msvcrt|ucrt|api-ms-win|KERNEL32|R\.dll" "$ARTDIR"/*.imports.txt > "$ARTDIR/imports.summary.txt" || true

          if [ -f "$PKGROOT/tinycc/lib/msvcrt.def" ]; then
            cp "$PKGROOT/tinycc/lib/msvcrt.def" "$ARTDIR/msvcrt.def"
            grep -Ein "ucrt|msvcrt|malloc|free|exit|abort" "$ARTDIR/msvcrt.def" > "$ARTDIR/msvcrt.def.summary.txt" || true
          fi

          if [ -f "$PKGROOT/tinycc/lib/R.def" ]; then
            cp "$PKGROOT/tinycc/lib/R.def" "$ARTDIR/R.def"
            grep -Ein "Rf_error|R_NilValue|R_RegisterCFinalizerEx" "$ARTDIR/R.def" > "$ARTDIR/R.def.summary.txt" || true
          fi

          {
            echo "PKGROOT=$PKGROOT"
            echo "--- tinycc/lib directory ---"
            ls -la "$PKGROOT/tinycc/lib" || true
            echo "--- tinycc/include directory ---"
            ls -la "$PKGROOT/tinycc/include" || true
          } > "$ARTDIR/tinycc-layout.txt"

          # Inspect key TinyCC Windows headers for CRT assumptions (msvcrt/ucrt and exit helpers).
          for hdr in \
            "$PKGROOT/tinycc/include/stdlib.h" \
            "$PKGROOT/tinycc/include/stdio.h" \
            "$PKGROOT/tinycc/include/winapi/wincrt.h" \
            "$PKGROOT/tinycc/include/winapi/_mingw.h"; do
            if [ -f "$hdr" ]; then
              base=$(basename "$hdr")
              cp "$hdr" "$ARTDIR/$base"
              grep -Ein "msvcrt|ucrt|__MSVCRT_VERSION__|_UCRT|_exit|exit|abort" "$hdr" > "$ARTDIR/$base.crt.summary.txt" || true
            fi
          done

      - name: Reproduce flaky post-test exit (plain check loop)
        id: plain
        shell: bash
        continue-on-error: true
        run: |
          set -eu
          RUNS="${{ github.event.inputs.runs || '3' }}"
          if [ -z "$RUNS" ]; then RUNS=3; fi
          echo "Running plain R CMD check up to $RUNS times"

          DEBUG_DIR="${RUNNER_TEMP:-$TMPDIR}/win_gdb"
          ARTDIR="$DEBUG_DIR/plain"
          mkdir -p "$ARTDIR"

          ok=0
          i=1
          while [ "$i" -le "$RUNS" ]; do
            echo "==== attempt $i/$RUNS ===="
            R CMD build . --no-build-vignettes > "$ARTDIR/build-$i.log" 2>&1 || true
            PKG=$(ls -1t *.tar.gz 2>/dev/null | head -n1)
            if [ -z "$PKG" ]; then
              echo "No tarball produced" | tee "$ARTDIR/check-$i.log"
            else
              set +e
              R CMD check --as-cran --no-manual "$PKG" > "$ARTDIR/check-$i.log" 2>&1
              rc=$?
              set -e
              echo "attempt $i rc=$rc" | tee -a "$ARTDIR/check-$i.log"
              if [ "$rc" -eq 0 ]; then
                ok=1
                break
              fi
            fi
            i=$((i+1))
          done

          if [ "$ok" -eq 1 ]; then
            echo "plain_success=1" >> "$GITHUB_OUTPUT"
          else
            echo "plain_success=0" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Run check under gdb and capture backtrace on crash
        if: steps.plain.outputs.plain_success == '0'
        shell: bash
        continue-on-error: true
        run: |
          set -euxo pipefail

          DEBUG_DIR="${RUNNER_TEMP:-$TMPDIR}/win_gdb"
          ARTDIR="$DEBUG_DIR/gdb"
          mkdir -p "$ARTDIR"

          R CMD build . --no-build-vignettes > "$ARTDIR/build.log" 2>&1
          PKG=$(ls -1t *.tar.gz | head -n1)

          # Catch crash signals and print stack only when a signal is trapped.
          cat > "$ARTDIR/gdb.cmd" <<'GDBCMD'
          set pagination off
          set print thread-events off
          set confirm off
          set breakpoint pending on
          break abort
          commands
            info sharedlibrary
            bt full
            thread apply all bt full
            quit 86
          end
          break _exit
          commands
            info sharedlibrary
            bt full
            thread apply all bt full
            quit 87
          end
          break exit
          commands
            info sharedlibrary
            bt full
            thread apply all bt full
            quit 88
          end
          catch signal SIGSEGV
          commands
            info sharedlibrary
            bt full
            thread apply all bt full
            quit 89
          end
          catch signal SIGABRT
          commands
            info sharedlibrary
            bt full
            thread apply all bt full
            quit 90
          end
          run
          quit
          GDBCMD

          set +e
          gdb --batch -x "$ARTDIR/gdb.cmd" \
            --args R CMD check --as-cran --no-manual "$PKG" > "$ARTDIR/gdb.log" 2>&1
          GDB_RC=$?
          set -e
          echo "gdb_exit_code=$GDB_RC" | tee -a "$ARTDIR/gdb.log"

      - name: Upload debug artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: win_gdb-artifacts
          path: |
            ${{ runner.temp }}/win_gdb/**
            *.Rcheck/**
          if-no-files-found: warn
